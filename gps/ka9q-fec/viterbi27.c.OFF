/* K=7 r=1/2 Viterbi decoder in portable C - wraparound version that can work in stream mode
 * This is for you, Doug!
 * Oct 2009, Phil Karn, KA9Q
 */

#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <assert.h>
#include "fec.h"

#define V27MAGIC 0x0102fffe

static int V27_init;

typedef union { long long p; unsigned int w[2]; } decision_t;

unsigned char Branchtab27_1[32] __attribute__ ((aligned(32)));
unsigned char Branchtab27_2[32] __attribute__ ((aligned(32)));

/* State info for instance of Viterbi decoder
 * Don't change this without also changing references in [mmx|sse|sse2]bfly29.s!
 */
struct v27 {
  unsigned int metrics1[64]; /* path metric buffer 1 */
  unsigned int metrics2[64]; /* path metric buffer 2 */
  decision_t *dp;              /* Pointer to decision output for current bit */
  unsigned int *old_metrics,*new_metrics; /* Pointers to path metrics, swapped on every bit */
  int length;
  int magic;
  /* Decision array follows this point, 64 bytes/length bit */
};

/* Initialize metric tables */
void set_viterbi27_polynomial(int polys[2]){
  int state;

  for(state=0;state < 32;state++){
    Branchtab27_1[state] = ((polys[0] < 0) ^ parityb((2*state) & abs(polys[0]))) ? 255 : 0;
    Branchtab27_2[state] = ((polys[1] < 0) ^ parityb((2*state) & abs(polys[1]))) ? 255 : 0;
  }
  V27_init = 1;
}

/* Create a new instance of a Viterbi decoder */
void *create_viterbi27(int len){
  struct v27 *vp;

  if(!V27_init){
    /* Default to these if user hasn't called himself */
    int polys[2] = { V27POLYA, V27POLYB };
    set_viterbi27_polynomial(polys);
  }

  vp = (struct v27 *)malloc(sizeof(struct v27) + len * sizeof(decision_t));
  vp->length = len;
  vp->magic = V27MAGIC;
  init_viterbi27(vp,0); /* Call init_viterbi27 yourself if you want a different state */
  return vp;
}

/* Initialize Viterbi decoder for start of new frame */
int init_viterbi27(void *p,int starting_state){
  struct v27 *vp = (struct v27 *) p;

  assert(vp->magic == V27MAGIC);
  memset(vp->metrics1,60,64);
  vp->old_metrics = vp->metrics1;
  vp->new_metrics = vp->metrics2;
  vp->dp = (decision_t *)(vp+1);
  vp->old_metrics[starting_state & 63] = 0; /* Bias known start state */
  return 0;
}

/* Do Viterbi chainback */
int chainback_viterbi27(
      void *p,
      unsigned char *data, /* Decoded output data */
      unsigned int nbits, /* Number of data bits */
      unsigned int endstate){ /* Terminal encoder state */

  struct v27 *vp = (struct v27 *) p;
  decision_t *d;

  assert(vp->magic == V27MAGIC);
  /* Make room beyond the end of the encoder register so we can
   * accumulate a full byte of decoded data
   */
  endstate %= 64;
  endstate <<= 2;

  d = vp->dp;
  while(nbits-- != 0){
    int k;

    if(--d < (decision_t *)(vp+1))
      d = (decision_t *)(vp + 1) + vp->length - 1; /* Wrap back to last element of decision array */

    k = (d->w[(endstate>>2)/32] >> ((endstate>>2)%32)) & 1;
    /* The store into data[] only needs to be done every 8 bits.
     * But this avoids a conditional branch, and the writes will
     * combine in the cache anyway
     */
    data[nbits>>3] = endstate = (endstate >> 1) | (k << 7);
  }
  return 0;
}

/* Delete instance of a Viterbi decoder */
void delete_viterbi27(void *p){
  struct v27 *vp;

  vp = (struct v27 *)p;
  assert(V27MAGIC == vp->magic);
  if(p != NULL) {
    vp->magic = 0;
    free(p);
  }
}
/* Portable C version */
/* C-language butterfly */
#define BFLY(i) {\
unsigned int metric,m0,m1,decision;\
    metric = (Branchtab27_1[i] ^ syms[0]) + (Branchtab27_2[i] ^ syms[1]);\
    m0 = vp->old_metrics[i] + metric;\
    m1 = vp->old_metrics[i+32] + (511 - metric);\
    decision = (int)(m0-m1) >= 0;		\
    vp->new_metrics[2*i] = decision ? m1 : m0;\
    vp->dp->w[i/16] |= decision << ((2*i)&31);\
    m0 -= (metric+metric-511);\
    m1 += (metric+metric-511);\
    decision = (int)(m0-m1) >= 0;	\
    vp->new_metrics[2*i+1] = decision ? m1 : m0;\
    vp->dp->w[i/16] |= decision << ((2*i+1)&31);\
}

int update_viterbi27_blk(void *p,unsigned char *syms,int nbits){
  struct v27 *vp = (struct v27 *) p;
  unsigned int *tmp;
  int normalize = 0;

  assert(vp->magic == V27MAGIC);
  while(nbits-- != 0){

    vp->dp->w[0] = vp->dp->w[1] = 0;

    BFLY(0);
    BFLY(1);
    BFLY(2);
    BFLY(3);
    BFLY(4);
    BFLY(5);
    BFLY(6);
    BFLY(7);
    BFLY(8);
    BFLY(9);
    BFLY(10);
    BFLY(11);
    BFLY(12);
    BFLY(13);
    BFLY(14);
    BFLY(15);
    BFLY(16);
    BFLY(17);
    BFLY(18);
    BFLY(19);
    BFLY(20);
    BFLY(21);
    BFLY(22);
    BFLY(23);
    BFLY(24);
    BFLY(25);
    BFLY(26);
    BFLY(27);
    BFLY(28);
    BFLY(29);
    BFLY(30);
    BFLY(31);
    
    //    fprintf(stderr,"nbits %d syms %d %d; decisions %x %x\n",nbits,syms[0],syms[1],vp->dp->w[0],vp->dp->w[1]);
    /* Renormalize metrics */
    if(vp->new_metrics[0] > (1<<30)){
      int i;
      unsigned int minmetric = 1<<31;
      
      for(i=0;i<64;i++)
	if(vp->new_metrics[i] < minmetric)
	  minmetric = vp->new_metrics[i];
      for(i=0;i<64;i++)
	vp->new_metrics[i] -= minmetric;
      normalize += minmetric;
    }
    
    if(++(vp->dp) >= (decision_t *)(vp + 1) + vp->length)
      vp->dp = (decision_t *)(vp + 1); /* Wrap back to beginning */
    tmp = vp->old_metrics;
    vp->old_metrics = vp->new_metrics;
    vp->new_metrics = tmp;
    syms += 2;
  }    
  return normalize;
}
